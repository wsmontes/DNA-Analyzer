/**
 * @gmod/tabix v1.5.0 - Compatibility version
 * Tabix file format parser - Simplified for web worker compatibility
 *
 * @license MIT
 */
(function (global) {
  'use strict';

  // Create simplified tabix implementation that works in web workers
  const tabix = {};

  // Binary file reading utilities
  const fileUtils = {
    readInt32LE: function(buffer, offset) {
      return buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24);
    },
    
    readUInt32LE: function(buffer, offset) {
      return ((buffer[offset]) |
          (buffer[offset + 1] << 8) |
          (buffer[offset + 2] << 16)) +
          (buffer[offset + 3] * 0x1000000);
    },
    
    readUInt8: function(buffer, offset) {
      return buffer[offset];
    },
    
    readUInt64LE: function(buffer, offset) {
      return {
        lo: this.readUInt32LE(buffer, offset),
        hi: this.readUInt32LE(buffer, offset + 4)
      };
    }
  };

  // Basic IndexedFile class for tabix
  class TabixIndexedFile {
    constructor(options) {
      this.filehandle = options.filehandle;
      this.tbiFilehandle = options.tbiFilehandle;
      this.chunkSizeLimit = options.chunkSizeLimit || 1e7;
      
      if (this.tbiFilehandle) {
        this.loadIndex();
      }
    }

    async loadIndex() {
      const tbiData = await this.tbiFilehandle.readFile();
      this.index = this.parseTabixIndex(tbiData);
      return this.index;
    }

    parseTabixIndex(buffer) {
      // Simplified TBI parsing that handles the essential structure
      const view = new Uint8Array(buffer);
      let offset = 0;

      // Check magic number
      if (fileUtils.readInt32LE(view, offset) !== 0x01494254) { // "TBI\1"
        throw new Error('Not a valid TBI file');
      }
      offset += 4;

      // Parse header
      const version = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const format = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const colSeq = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const colBeg = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const colEnd = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const meta = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const skip = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      // Read sequence dictionary
      const nSeq = fileUtils.readInt32LE(view, offset);
      offset += 4;
      
      const seqNames = [];
      for (let i = 0; i < nSeq; i++) {
        let name = '';
        while (view[offset] !== 0) {
          name += String.fromCharCode(view[offset]);
          offset++;
        }
        seqNames.push(name);
        offset++; // Skip the null terminator
      }
      
      // For compatibility, return a simple structure
      return {
        format,
        columnNumbers: {
          ref: colSeq,
          start: colBeg,
          end: colEnd
        },
        metaChar: String.fromCharCode(meta),
        skipLines: skip,
        refNames: seqNames,
        indexType: 'TBI'
      };
    }

    // Basic utility to find chromosome name matches
    static matchRefName(name, refNames) {
      if (!name || !refNames) return false;
      if (refNames[name]) return name;
      
      // Try lowercase matching
      const lowercaseName = name.toLowerCase();
      for (const refName in refNames) {
        if (refName.toLowerCase() === lowercaseName) {
          return refName;
        }
      }
      return false;
    }
  }

  // Attach the class to the tabix namespace
  tabix.TabixIndexedFile = TabixIndexedFile;
  
  // Export to global scope for the worker
  global.tabix = tabix;

})(typeof self !== 'undefined' ? self : this);
